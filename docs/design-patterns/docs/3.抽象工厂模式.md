---
title: 3.抽象工厂模式
date: 2020-07-01
---
## 总结
这节先举个例子，然后把结论丢出来，带着例子和结论往下看。

### 举例
假设现在xxx公司有个`大老板`，每天啥活也不干，唯一的任务就是监督手下的几个经理，一旦哪个经理某件事没干，出问题了，找到他这里来，他就督促经理赶紧去吧这事办了。

**结论：我们这节所说的抽象类就是大老板这个角色**

## 简单工厂模式存在的问题
上一节介绍了简单工厂模式，拿生产手机来举例。上一节的代码适用于简单的创建对象需求，一旦对象类别过多，简单工厂模式就不适用了，违反了我们一开始说的设计模式中的**开放封闭原则**

具体是哪违反了呢，上一节我们的`getPhone`可以生产`iphone11`和`mate30`，但是现实中一个手机工厂肯定不是只生产这两种型号的手机的，而且生产的手机也是每年在变的，比如今年生产`mate30`，明年可能就转向生产`mate40`了。

如果要在代码中实现上面的逻辑的话，你会怎么做，肯定会想，那我新加一个型号的手机，我在`switch`中在加一个`case`不就行了吗，比如要加一个小米10，代码如下：
```js
function getPhone(name) {
  let params = [];
  switch (name) {
    case "iphone11":
      params = ["A13", "索尼", "康宁",, "ios"];
      break;
    case "mate30":
      params = ["麒麟990", "莱卡", "康宁", "安卓"];
      break;
    // 添加小米10
    case "小米10":
      params = ["骁龙865", "索尼", "康宁", "安卓"];
      break;
    default:
      params = [];
      break;
  }
  return new Phone(...params);
}
```
上面只有3中手机，现实中可能有几十种，加上更新换代的手机，可能有几百种型号，如果每次有改动都去修改`getPhone`函数的话，当手机型号有几百种，这个`switch`变得巨大无比的时候，试问公司人谁敢去动这个函数，一旦不小心把哪里改错了，一个大锅就背你身上了。而且像我们上面所说，违反了设计模式中的**开放封闭原则**

**开放封闭原则**就是：对扩展开放，对修改封闭。拿上面那个`getPhone`来举例，这是一个公共的函数，我们可以对它进行扩展，但是不要对它进行修改。那说半天，具体咋扩展呢，就引出了下面的**抽象工厂模式**

## 抽象工厂模式
**简单工厂模式**其实可以类比`华强北小厂`，一个小厂总共山寨的也就那么几款手机，肯定是越简单，越省事好。但是到了`富士康`这种大厂，就不太适用了，就需要一种更加灵活可扩展的方式了。类比到编程，简单的创建对象可以用简单工厂模式，方便快捷，到了复杂的创建对象上就需要更加灵活多变的模式了。

抽象工厂模式会有个总的抽象类，你可以把它当成公司大boss，只管着公司重要的事情，一些零碎的事情下面的主管复杂，如果你因为小事去找大boss，大boss就会提醒你，然你去找你的上级主管去。按照这个思路来修改上面的代码。
```js
// 大boss(抽象类)
class Phone {
  createCPU() {
    throw Error("抽象方法不允许直接调用，需要在具体工厂中重写这个方法");
  }
  createOS() {
    throw Error("抽象方法不允许直接调用，需要在具体工厂中重写这个方法");
  }
}
// Iphone生产线（iphone部门主管）
class Iphone extends Phone {
  createCPU(cpu) {
    this.cpu = cpu;
  }
  createOS(os) {
    this.os = os;
  }
}

// mate生产线（mate部门主管）
class Mate extends Phone {
  createCPU(cpu) {
    this.cpu = cpu;
  }
  // 这里故意没有重写createOS方法，后边代码中会说到
}
```
上面代码先别管有啥用，能看懂的话，继续往下看
```js
// 生产iphone
let iphone = new Iphone();
// 给iphone添加cpu
iphone.createCPU();
// 添加操作系统
iphone.createOS();

// 生产mate30
let mate30 = new Mate();
// 添加cpu
mate30.createCPU('麒麟990')
// 添加操作系统
// 注意：因为我们没有在Mate类中重写createOS方法，所以createOS就会向上找到Phone中的createOS方法，抛出一个错误提示我们
// 相当与你因为一件小事直接去找大boss
mate30.createOS('android')
```
上面这种写法乍一看啥也不是，还搞复杂了，但是它满足了封闭开放原则，假如你要新加一条小米10的生产线，那只需要像下面这样添加一个继承自抽象类Phone的类就可以了：
```js
class XiaoMi extends Phone {
  createCPU(cpu) {
    this.cpu = cpu;
  }
  createOS(os) {
    this.os = os;
  }
}
```
这样你新加什么东西都不会影响到原有的代码逻辑，新增一条生产线都是在扩展Phone的子类而已。

## 结论
**抽象工厂模式**定义就是围绕一个`超级工厂`去创建`其它工厂`，具体生产任务都是`其它工厂`来干，超级工厂负责兜底，一旦发现某个工厂没好好干活，就给出提醒，督促赶紧完善。

抽象工厂这种模式在前端用的不多，所以做前端的**了解了解就好**，知道是干嘛的就成。但是好像像java这种面对对象的语言用的很多。

:::tip
- **抽象工厂模式**对应复杂多变的场景，处理一些比较繁杂的类，并且后期会有各种扩展行的需求
- **简单工厂模式**对应简单稳定的场景，处理一些少量的，变化性不大，后期也不会大量变动的类，这种场景就怎么省事怎么来，也不用太考虑扩展性啊什么的。